#include <cfloat>
#include <assert.h>
#include "math/vecmath.hpp"
#include "math/matmath.hpp"
// #include "color.h"

using std::isnan;
using std::isinf;


/*
    pbrt source code Copyright(c) 1998-2012 Matt Pharr and Greg Humphreys.
    This file is part of pbrt.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:
    - Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

inline int SHTerms(int lmax) {
    return (lmax + 1) * (lmax + 1);
}
inline int SHIndex(int l, int m) {
    return l*l+l+m;
}
static inline float divfact(int a, int b) {
    if (b == 0) return 1.f;
    float fa = a, fb = fabs(b);
    float v = 1.f;
    for (float x = fa-fb+1.f; x <= fa+fb; x += 1.f)
        v *= x;
    return 1.f / v;
}
#define INV_FOURPI 0.07957747154594766788f
inline float K(int l, int m) {
    return sqrtf((2.f * l + 1.f) * INV_FOURPI * divfact(l, m));
}


static void sinCosIndexed(float s, float c, int n,
                          float *sout, float *cout) {
    float si = 0, ci = 1;
    for (int i = 0; i < n; ++i) {
        // Compute $\sin{}i\phi$ and $\cos{}i\phi$ using recurrence
        *sout++ = si;
        *cout++ = ci;
        float oldsi = si;
        si = si * c + ci * s;
        ci = ci * c - oldsi * s;
    }
}


// evaluate Legendre polynomials at x (pbrt-v2)
static void legendrep(float x, int lmax, float *out) {
#define P(l,m) out[SHIndex(l,m)]
    // Compute $m=0$ Legendre values using recurrence
    P(0,0) = 1.f;
    P(1,0) = x;
    for (int l = 2; l <= lmax; ++l)
    {
        P(l, 0) = ((2*l-1)*x*P(l-1,0) - (l-1)*P(l-2,0)) / l;
        assert(!isnan(P(l, 0)));
        assert(!isinf(P(l, 0)));
    }

    // Compute $m=l$ edge using Legendre recurrence
    float neg = -1.f;
    float dfact = 1.f;
    float xroot = sqrtf(fmax(0.f, 1.f - x*x));
    float xpow = xroot;
    for (int l = 1; l <= lmax; ++l) {
        P(l, l) = neg * dfact * xpow;
        assert(!isnan(P(l, l)));
        assert(!isinf(P(l, l)));
        neg *= -1.f;      // neg = (-1)^l
        dfact *= 2*l + 1; // dfact = (2*l-1)!!
        xpow *= xroot;    // xpow = powf(1.f - x*x, float(l) * 0.5f);
    }

    // Compute $m=l-1$ edge using Legendre recurrence
    for (int l = 2; l <= lmax; ++l)
    {
        P(l, l-1) = x * (2*l-1) * P(l-1, l-1);
        assert(!isnan(P(l, l-1)));
        assert(!isinf(P(l, l-1)));
    }

    // Compute $m=1, \ldots, l-2$ values using Legendre recurrence
    for (int l = 3; l <= lmax; ++l)
        for (int m = 1; m <= l-2; ++m)
        {
            P(l, m) = ((2 * (l-1) + 1) * x * P(l-1,m) -
                       (l-1+m) * P(l-2,m)) / (l - m);
            assert(!isnan(P(l, m)));
            assert(!isinf(P(l, m)));
        }
    #if 0
        // wrap up with the negative m ones now
        // P(l,-m)(x) = -1^m (l-m)!/(l+m)! P(l,m)(x)
        for (int l = 1; l <= lmax; ++l) {
            float fa = 1.f, fb = fact(2*l);
            // fa = fact(l+m), fb = fact(l-m)
            for (int m = -l; m < 0; ++m) {
                float neg = ((-m) & 0x1) ? -1.f : 1.f;
                P(l,m) = neg * fa/fb * P(l,-m);
                fb /= l-m;
                fa *= (l+m+1) > 1 ? (l+m+1) : 1.;
            }
        }
    #endif
#undef P
}

// evaluate basis at w
void SHEvaluate(const vec3f &w, int lmax, float *out) {
    assert(lmax <= 28);
    // if (lmax > 28) {
    //     console.error("SHEvaluate() runs out of numerical precision for lmax > 28. "
    //            "If you need more bands, try recompiling using doubles.");
    //     exit(1);
    // }

    // Compute Legendre polynomial values for $\cos\theta$
    assert(norm(w) > .995f && norm(w) < 1.005f);
    legendrep(w.z, lmax, out);

    // Compute $K_l^m$ coefficients
    float Klm[SHTerms(lmax)];
    for (int l = 0; l <= lmax; ++l)
        for (int m = -l; m <= l; ++m)
            Klm[SHIndex(l, m)] = K(l, m);

    // Compute $\sin\phi$ and $\cos\phi$ values
    float sins[lmax+1], coss[lmax+1];
    float xyLen = sqrtf(fmax(0.f, 1.f - w.z*w.z));
    if (xyLen == 0.f) {
        for (int i = 0; i <= lmax; ++i) sins[i] = 0.f;
        for (int i = 0; i <= lmax; ++i) coss[i] = 1.f;
    }
    else
        sinCosIndexed(w.y / xyLen, w.x / xyLen, lmax+1, sins, coss);

    // Apply SH definitions to compute final $(l,m)$ values
    static const float sqrt2 = sqrtf(2.f);
    for (int l = 0; l <= lmax; ++l) {
        for (int m = -l; m < 0; ++m)
        {
            out[SHIndex(l, m)] = sqrt2 * Klm[SHIndex(l, m)] *
                out[SHIndex(l, -m)] * sins[-m];
            assert(!isnan(out[SHIndex(l,m)]));
            assert(!isinf(out[SHIndex(l,m)]));
        }
        out[SHIndex(l, 0)] *= Klm[SHIndex(l, 0)];
        for (int m = 1; m <= l; ++m)
        {
            out[SHIndex(l, m)] *= sqrt2 * Klm[SHIndex(l, m)] * coss[m];
            assert(!isnan(out[SHIndex(l,m)]));
            assert(!isinf(out[SHIndex(l,m)]));
        }
    }
}


static void toZYZ(const mat4f &m, float *alpha, float *beta, float *gamma);
typedef float rot_data_t;
void SHRotateXMinus(const rot_data_t *c_in, rot_data_t *c_out, int lmax);
void SHRotateXPlus(const rot_data_t *c_in, rot_data_t *c_out, int lmax);
void SHRotateZ(const rot_data_t *c_in, rot_data_t *c_out, float alpha, int lmax);

//============ rotation implementation starts ==============

void SHRotate(const rot_data_t *c_in, rot_data_t *c_out, const mat4f &m, int lmax)
{
    float alpha, beta, gamma;
    toZYZ(m, &alpha, &beta, &gamma);
    rot_data_t work[SHTerms(lmax)];
    SHRotateZ(c_in, c_out, gamma, lmax);
    SHRotateXPlus(c_out, work, lmax);
    SHRotateZ(work, c_out, beta, lmax);
    SHRotateXMinus(c_out, work, lmax);
    SHRotateZ(work, c_out, alpha, lmax);
}



// TODO check matrix row/column major
static void toZYZ(const mat4f &m, float *alpha, float *beta, float *gamma) {
#define M(a, b) (m[a][b])

    float sy = sqrtf(M(2,1)*M(2,1) + M(2,0)*M(2,0));
    if (sy > 16*FLT_EPSILON) {
        *gamma = -atan2f(M(1,2), -M(0,2));
        *beta  = -atan2f(sy, M(2,2));
        *alpha = -atan2f(M(2,1), M(2,0));
    } else {
        *gamma =  0;
        *beta  = -atan2f(sy, M(2,2));
        *alpha = -atan2f(-M(1,0), M(1,1));
    }
#undef M
}


void SHRotateZ(const rot_data_t *c_in, rot_data_t *c_out, float alpha,
               int lmax) {
    assert(c_in != c_out);
    c_out[0] = c_in[0];
    if (lmax == 0) return;
    // Precompute sine and cosine terms for $z$-axis SH rotation
    float ct[lmax+1];
    float st[lmax+1];
    sinCosIndexed(sinf(alpha), cosf(alpha), lmax+1, st, ct);
    for (int l = 1; l <= lmax; ++l) {
        // Rotate coefficients for band _l_ about $z$
        for (int m = -l; m < 0; ++m)
            c_out[SHIndex(l, m)] =
                ( ct[-m] * c_in[SHIndex(l,  m)] +
                 -st[-m] * c_in[SHIndex(l, -m)]);
        c_out[SHIndex(l, 0)] = c_in[SHIndex(l, 0)];
        for (int m = 1; m <= l; ++m)
            c_out[SHIndex(l, m)] =
                (ct[m] * c_in[SHIndex(l,  m)] +
                 st[m] * c_in[SHIndex(l, -m)]);
    }
}


// Spherical Harmonics Rotations Definitions
void SHRotateXMinus(const rot_data_t *c_in, rot_data_t *c_out, int lmax) {
    // -x rotations are the same as +x rotations, just with a negation
    // factor thrown in for some of the terms.
    SHRotateXPlus(c_in, c_out, lmax);

    // l = 0 band is a no op...
    for (int l = 1; l <= lmax; ++l) {
        float s = (l & 0x1) ? -1.f : 1.f;
        c_out[SHIndex(l, 0)] *= s;
        for (int m = 1; m <= l; ++m) {
            s = -s;
            c_out[SHIndex(l, m)] *= s;
            c_out[SHIndex(l, -m)] *= -s;
        }
    }
}


void SHRotateXPlus(const rot_data_t *c_in, rot_data_t *c_out, int lmax) {
#define O(l, m)  c_in[SHIndex(l, m)]

    // first band is a no-op
    *c_out++ = c_in[0];

    if (lmax < 1) return;
    *c_out++ = (O(1,0));
    *c_out++ = (-1.*O(1,-1));
    *c_out++ = (O(1,1));

    if (lmax < 2) return;
    *c_out++ = (O(2,1));
    *c_out++ = (-1.*O(2,-1));
    *c_out++ = (-0.5*O(2,0) - 0.8660254037844386*O(2,2));
    *c_out++ = (-1.*O(2,-2));
    *c_out++ = (-0.8660254037844386*O(2,0) + 0.5*O(2,2));

    // Remainder of SH $x+$ rotation definition
    if (lmax < 3) return;
    *c_out++ = (-0.7905694150420949*O(3,0) + 0.6123724356957945*O(3,2));
    *c_out++ = (-1.*O(3,-2));
    *c_out++ = (-0.6123724356957945*O(3,0) - 0.7905694150420949*O(3,2));
    *c_out++ = (0.7905694150420949*O(3,-3) + 0.6123724356957945*O(3,-1));
    *c_out++ = (-0.25*O(3,1) - 0.9682458365518543*O(3,3));
    *c_out++ = (-0.6123724356957945*O(3,-3) + 0.7905694150420949*O(3,-1));
    *c_out++ = (-0.9682458365518543*O(3,1) + 0.25*O(3,3));
    
    if (lmax < 4) return;
    *c_out++ = (-0.9354143466934853*O(4,1) + 0.35355339059327373*O(4,3));
    *c_out++ = (-0.75*O(4,-3) + 0.6614378277661477*O(4,-1));
    *c_out++ = (-0.35355339059327373*O(4,1) - 0.9354143466934853*O(4,3));
    *c_out++ = (0.6614378277661477*O(4,-3) + 0.75*O(4,-1));
    *c_out++ = (0.375*O(4,0) + 0.5590169943749475*O(4,2) + 0.739509972887452*O(4,4));
    *c_out++ = (0.9354143466934853*O(4,-4) + 0.35355339059327373*O(4,-2));
    *c_out++ = (0.5590169943749475*O(4,0) + 0.5*O(4,2) - 0.6614378277661477*O(4,4));
    *c_out++ = (-0.35355339059327373*O(4,-4) + 0.9354143466934853*O(4,-2));
    *c_out++ = (0.739509972887452*O(4,0) - 0.6614378277661477*O(4,2) + 0.125*O(4,4));
    
    if (lmax < 5) return;
    *c_out++ = (0.701560760020114*O(5,0) - 0.6846531968814576*O(5,2) +
                0.19764235376052372*O(5,4));
    *c_out++ = (-0.5*O(5,-4) + 0.8660254037844386*O(5,-2));
    *c_out++ = (0.5229125165837972*O(5,0) + 0.30618621784789724*O(5,2) -
                0.795495128834866*O(5,4));
    *c_out++ = (0.8660254037844386*O(5,-4) + 0.5*O(5,-2));
    *c_out++ = (0.4841229182759271*O(5,0) + 0.6614378277661477*O(5,2) +
                0.57282196186948*O(5,4));
    *c_out++ = (-0.701560760020114*O(5,-5) - 0.5229125165837972*O(5,-3) -
                0.4841229182759271*O(5,-1));
    *c_out++ = (0.125*O(5,1) + 0.4050462936504913*O(5,3) + 0.9057110466368399*O(5,5));
    *c_out++ = (0.6846531968814576*O(5,-5) - 0.30618621784789724*O(5,-3) -
                0.6614378277661477*O(5,-1));
    *c_out++ = (0.4050462936504913*O(5,1) + 0.8125*O(5,3) - 0.4192627457812106*O(5,5));
    *c_out++ = (-0.19764235376052372*O(5,-5) + 0.795495128834866*O(5,-3) -
                0.57282196186948*O(5,-1));
    *c_out++ = (0.9057110466368399*O(5,1) - 0.4192627457812106*O(5,3) + 0.0625*O(5,5));
    
    if (lmax < 6) return;
    *c_out++ = (0.879452954966893*O(6,1) - 0.46351240544347894*O(6,3) +
                0.10825317547305482*O(6,5));
    *c_out++ = (-0.3125*O(6,-5) + 0.8028270361665706*O(6,-3) - 0.5077524002897476*O(6,-1));
    *c_out++ = (0.4330127018922193*O(6,1) + 0.6846531968814576*O(6,3) -
                0.5863019699779287*O(6,5));
    *c_out++ = (0.8028270361665706*O(6,-5) - 0.0625*O(6,-3) - 0.5929270612815711*O(6,-1));
    *c_out++ = (0.19764235376052372*O(6,1) + 0.5625*O(6,3) + 0.8028270361665706*O(6,5));
    *c_out++ = (-0.5077524002897476*O(6,-5) - 0.5929270612815711*O(6,-3) -
                0.625*O(6,-1));
    *c_out++ = (-0.3125*O(6,0) - 0.45285552331841994*O(6,2) - 0.49607837082461076*O(6,4) -
                0.6716932893813962*O(6,6));
    *c_out++ = (-0.879452954966893*O(6,-6) - 0.4330127018922193*O(6,-4) -
                0.19764235376052372*O(6,-2));
    *c_out++ = (-0.45285552331841994*O(6,0) - 0.53125*O(6,2) - 0.1711632992203644*O(6,4) +
                0.6952686081652184*O(6,6));
    *c_out++ = (0.46351240544347894*O(6,-6) - 0.6846531968814576*O(6,-4) -
                0.5625*O(6,-2));
    *c_out++ = (-0.49607837082461076*O(6,0) - 0.1711632992203644*O(6,2) +
                0.8125*O(6,4) - 0.2538762001448738*O(6,6));
    *c_out++ = (-0.10825317547305482*O(6,-6) + 0.5863019699779287*O(6,-4) -
                0.8028270361665706*O(6,-2));
    *c_out++ = (-0.6716932893813962*O(6,0) + 0.6952686081652184*O(6,2) -
                0.2538762001448738*O(6,4) + 0.03125*O(6,6));
    
    if (lmax < 7) return;
    *c_out++ = (-0.6472598492877494*O(7,0) + 0.6991205412874092*O(7,2) -
                0.2981060004427955*O(7,4) + 0.05846339666834283*O(7,6));
    *c_out++ = (-0.1875*O(7,-6) + 0.6373774391990981*O(7,-4) - 0.7473912964438374*O(7,-2));
    *c_out++ = (-0.47495887979908324*O(7,0) - 0.07328774624724109*O(7,2) +
                0.78125*O(7,4) - 0.3983608994994363*O(7,6));
    *c_out++ = (0.6373774391990981*O(7,-6) - 0.5*O(7,-4) - 0.5863019699779287*O(7,-2));
    *c_out++ = (-0.42961647140211*O(7,0) - 0.41984465132951254*O(7,2) +
                0.10364452469860624*O(7,4) + 0.7927281808728639*O(7,6));
    *c_out++ = (-0.7473912964438374*O(7,-6) - 0.5863019699779287*O(7,-4) -
                0.3125*O(7,-2));
    *c_out++ = (-0.41339864235384227*O(7,0) - 0.5740991584648073*O(7,2) -
                0.5385527481129402*O(7,4) - 0.4576818286211503*O(7,6));
    *c_out++ = (0.6472598492877494*O(7,-7) + 0.47495887979908324*O(7,-5) +
                0.42961647140211*O(7,-3) + 0.41339864235384227*O(7,-1));
    *c_out++ = (-0.078125*O(7,1) - 0.24356964481437335*O(7,3) - 0.4487939567607835*O(7,5) -
                0.8562442974262661*O(7,7));
    *c_out++ = (-0.6991205412874092*O(7,-7) + 0.07328774624724109*O(7,-5) +
                0.41984465132951254*O(7,-3) + 0.5740991584648073*O(7,-1));
    *c_out++ = (-0.24356964481437335*O(7,1) - 0.609375*O(7,3) - 0.5700448858423344*O(7,5) +
                0.4943528756111367*O(7,7));
    *c_out++ = (0.2981060004427955*O(7,-7) - 0.78125*O(7,-5) - 0.10364452469860624*O(7,-3) +
                0.5385527481129402*O(7,-1));
    *c_out++ = (-0.4487939567607835*O(7,1) - 0.5700448858423344*O(7,3) + 0.671875*O(7,5) -
                0.14905300022139775*O(7,7));
    *c_out++ = (-0.05846339666834283*O(7,-7) + 0.3983608994994363*O(7,-5) -
                0.7927281808728639*O(7,-3) + 0.4576818286211503*O(7,-1));
    *c_out++ = (-0.8562442974262661*O(7,1) + 0.4943528756111367*O(7,3) -
                0.14905300022139775*O(7,5) + 0.015625*O(7,7));
    
    if (lmax < 8) return;
    *c_out++ = (-0.8356088723200586*O(8,1) + 0.516334738808072*O(8,3) -
                0.184877493221863*O(8,5) + 0.03125*O(8,7));
    *c_out++ = (-0.109375*O(8,-7) + 0.4621937330546575*O(8,-5) - 0.774502108212108*O(8,-3) +
                0.4178044361600293*O(8,-1));
    *c_out++ = (-0.4576818286211503*O(8,1) - 0.47134697278119864*O(8,3) +
                0.7088310138883598*O(8,5) - 0.2567449488305466*O(8,7));
    *c_out++ = (0.4621937330546575*O(8,-7) - 0.703125*O(8,-5) - 0.2181912506838897*O(8,-3) +
                0.4943528756111367*O(8,-1));
    *c_out++ = (-0.27421763710600383*O(8,1) - 0.6051536478449089*O(8,3) -
                0.33802043207474897*O(8,5) + 0.6665852814906732*O(8,7));
    *c_out++ = (-0.774502108212108*O(8,-7) - 0.2181912506838897*O(8,-5) +
                0.265625*O(8,-3) + 0.5310201708739509*O(8,-1));
    *c_out++ = (-0.1307281291459493*O(8,1) - 0.38081430021731066*O(8,3) -
                0.5908647000371574*O(8,5) - 0.6991205412874092*O(8,7));
    *c_out++ = (0.4178044361600293*O(8,-7) + 0.4943528756111367*O(8,-5) +
                0.5310201708739509*O(8,-3) + 0.546875*O(8,-1));
    *c_out++ = (0.2734375*O(8,0) + 0.3921843874378479*O(8,2) + 0.4113264556590057*O(8,4) +
                0.4576818286211503*O(8,6) + 0.626706654240044*O(8,8));
    *c_out++ = (0.8356088723200586*O(8,-8) + 0.4576818286211503*O(8,-6) +
                0.27421763710600383*O(8,-4) + 0.1307281291459493*O(8,-2));
    *c_out++ = (0.3921843874378479*O(8,0) + 0.5*O(8,2) + 0.32775276505317236*O(8,4) -
                0.6991205412874092*O(8,8));
    *c_out++ = (-0.516334738808072*O(8,-8) + 0.47134697278119864*O(8,-6) +
                0.6051536478449089*O(8,-4) + 0.38081430021731066*O(8,-2));
    *c_out++ = (0.4113264556590057*O(8,0) + 0.32775276505317236*O(8,2) -
                0.28125*O(8,4) - 0.7302075903467452*O(8,6) + 0.3332926407453366*O(8,8));
    *c_out++ = (0.184877493221863*O(8,-8) - 0.7088310138883598*O(8,-6) +
                0.33802043207474897*O(8,-4) + 0.5908647000371574*O(8,-2));
    *c_out++ = (0.4576818286211503*O(8,0) - 0.7302075903467452*O(8,4) + 0.5*O(8,6) -
                0.0855816496101822*O(8,8));
    *c_out++ = (-0.03125*O(8,-8) + 0.2567449488305466*O(8,-6) - 0.6665852814906732*O(8,-4) +
                0.6991205412874092*O(8,-2));
    *c_out++ = (0.626706654240044*O(8,0) - 0.6991205412874092*O(8,2) +
                0.3332926407453366*O(8,4) - 0.0855816496101822*O(8,6) + 0.0078125*O(8,8));
    
    if (lmax < 9) return;
    *c_out++ = (0.6090493921755238*O(9,0) - 0.6968469725305549*O(9,2) +
                0.3615761395439417*O(9,4) - 0.11158481919598204*O(9,6) + 0.016572815184059706*O(9,8));
    *c_out++ = (-0.0625*O(9,-8) + 0.3156095293238149*O(9,-6) - 0.6817945071647321*O(9,-4) +
                0.656993626300895*O(9,-2));
    *c_out++ = (0.44314852502786806*O(9,0) - 0.05633673867912483*O(9,2) - 0.6723290616859425*O(9,4) +
                0.5683291712335379*O(9,6) - 0.1594400908746762*O(9,8));
    *c_out++ = (0.3156095293238149*O(9,-8) - 0.71875*O(9,-6) + 0.20252314682524564*O(9,-4) +
                0.5854685623498499*O(9,-2));
    *c_out++ = (0.39636409043643195*O(9,0) + 0.25194555463432966*O(9,2) - 0.3921843874378479*O(9,4) -
                0.6051536478449089*O(9,6) + 0.509312687906457*O(9,8));
    *c_out++ = (-0.6817945071647321*O(9,-8) + 0.20252314682524564*O(9,-6) + 0.5625*O(9,-4) +
                0.4215855488510013*O(9,-2));
    *c_out++ = (0.3754879637718099*O(9,0) + 0.42961647140211*O(9,2) + 0.13799626353637262*O(9,4) -
                0.2981060004427955*O(9,6) - 0.7526807559068452*O(9,8));
    *c_out++ = (0.656993626300895*O(9,-8) + 0.5854685623498499*O(9,-6) + 0.4215855488510013*O(9,-4) +
                0.21875*O(9,-2));
    *c_out++ = (0.36685490255855924*O(9,0) + 0.5130142237306876*O(9,2) + 0.4943528756111367*O(9,4) +
                0.4576818286211503*O(9,6) + 0.38519665736315783*O(9,8));
    *c_out++ = (-0.6090493921755238*O(9,-9) - 0.44314852502786806*O(9,-7) - 0.39636409043643195*O(9,-5) -
                0.3754879637718099*O(9,-3) - 0.36685490255855924*O(9,-1));
    *c_out++ = (0.0546875*O(9,1) + 0.16792332234534904*O(9,3) + 0.2954323500185787*O(9,5) +
                0.4624247721758373*O(9,7) + 0.8171255055356398*O(9,9));
    *c_out++ = (0.6968469725305549*O(9,-9) + 0.05633673867912483*O(9,-7) - 0.25194555463432966*O(9,-5) -
                0.42961647140211*O(9,-3) - 0.5130142237306876*O(9,-1));
    *c_out++ = (0.16792332234534904*O(9,1) + 0.453125*O(9,3) + 0.577279787559724*O(9,5) +
                0.387251054106054*O(9,7) - 0.5322256665703469*O(9,9));
    *c_out++ = (-0.3615761395439417*O(9,-9) + 0.6723290616859425*O(9,-7) + 0.3921843874378479*O(9,-5) -
                0.13799626353637262*O(9,-3) - 0.4943528756111367*O(9,-1));
    *c_out++ = (0.2954323500185787*O(9,1) + 0.577279787559724*O(9,3) + 0.140625*O(9,5) -
                0.7162405240429014*O(9,7) + 0.21608307321780204*O(9,9));
    *c_out++ = (0.11158481919598204*O(9,-9) - 0.5683291712335379*O(9,-7) + 0.6051536478449089*O(9,-5) +
                0.2981060004427955*O(9,-3) - 0.4576818286211503*O(9,-1));
    *c_out++ = (0.4624247721758373*O(9,1) + 0.387251054106054*O(9,3) - 0.7162405240429014*O(9,5) +
                0.34765625*O(9,7) - 0.048317644050206957*O(9,9));
    *c_out++ = (-0.016572815184059706*O(9,-9) + 0.1594400908746762*O(9,-7) - 0.509312687906457*O(9,-5) +
                0.7526807559068452*O(9,-3) - 0.38519665736315783*O(9,-1));
    *c_out++ = (0.8171255055356398*O(9,1) - 0.5322256665703469*O(9,3) + 0.21608307321780204*O(9,5) -
                0.048317644050206957*O(9,7) + 0.00390625*O(9,9));
    assert(lmax < 10);
    
#if 0
    if (lmax < 10) return;
    *c_out++ = (0.800447720175637*O(10,1) - 0.5437971423529642*O(10,3) + 0.24319347525427157*O(10,5) -
                0.06594508990677396*O(10,7) + 0.008734640537108554*O(10,9));
    *c_out++ = (-0.03515625*O(10,-9) + 0.20644078533943455*O(10,-7) - 0.5437971423529642*O(10,-5) +
                0.7295804257628147*O(10,-3) - 0.35797110294949086*O(10,-1));
    *c_out++ = (0.4645646483537033*O(10,1) + 0.3156095293238149*O(10,3) - 0.7057243619147634*O(10,5) +
                0.4210060495408587*O(10,7) - 0.09631896879639025*O(10,9));
    *c_out++ = (0.20644078533943455*O(10,-9) - 0.62890625*O(10,-7) + 0.5041938375082048*O(10,-5) +
                0.3543293897015177*O(10,-3) - 0.4267298778757763*O(10,-1));
    *c_out++ = (0.31049159295683837*O(10,1) + 0.5390625*O(10,3) - 0.017469281074217108*O(10,5) -
                0.6925528980529664*O(10,7) + 0.36479021288140734*O(10,9));
    *c_out++ = (-0.5437971423529642*O(10,-9) + 0.5041938375082048*O(10,-7) + 0.484375*O(10,-5) -
                0.034938562148434216*O(10,-3) - 0.46285353886245695*O(10,-1));
    *c_out++ = (0.19515618744994995*O(10,1) + 0.48613591206575135*O(10,3) + 0.4941058844013093*O(10,5) +
                0.09110862335695782*O(10,7) - 0.6878550219704731*O(10,9));
    *c_out++ = (0.7295804257628147*O(10,-9) + 0.3543293897015177*O(10,-7) - 0.034938562148434216*O(10,-5) -
                0.328125*O(10,-3) - 0.4829869223773042*O(10,-1));
    *c_out++ = (0.09472152853892297*O(10,1) + 0.2788526296496054*O(10,3) + 0.44538102542935076*O(10,5) +
                0.5748694230132831*O(10,7) + 0.6200241379499873*O(10,9));
    *c_out++ = (-0.35797110294949086*O(10,-9) - 0.4267298778757763*O(10,-7) - 0.46285353886245695*O(10,-5) -
                0.4829869223773042*O(10,-3) - 0.4921875*O(10,-1));
    *c_out++ = (-0.24609375*O(10,0) - 0.3512368283228746*O(10,2) - 0.3618292555284191*O(10,4) -
                0.3837778803237379*O(10,6) - 0.4306629552848579*O(10,8) - 0.5936279171365733*O(10,10));
    *c_out++ = (-0.800447720175637*O(10,-10) - 0.4645646483537033*O(10,-8) - 0.31049159295683837*O(10,-6) -
                0.19515618744994995*O(10,-4) - 0.09472152853892297*O(10,-2));
    *c_out++ = (-0.3512368283228746*O(10,0) - 0.46484375*O(10,2) - 0.36618880141431137*O(10,4) -
                0.18922142726223223*O(10,6) + 0.10058119679362292*O(10,8) + 0.6932080600734395*O(10,10));
    *c_out++ = (0.5437971423529642*O(10,-10) - 0.3156095293238149*O(10,-8) - 0.5390625*O(10,-6) -
                0.48613591206575135*O(10,-4) - 0.2788526296496054*O(10,-2));
    *c_out++ = (-0.3618292555284191*O(10,0) - 0.36618880141431137*O(10,2) + 0.015625*O(10,4) +
                0.4585145534256519*O(10,6) + 0.6137165055779013*O(10,8) - 0.38452264694764726*O(10,10));
    *c_out++ = (-0.24319347525427157*O(10,-10) + 0.7057243619147634*O(10,-8) + 0.017469281074217108*O(10,-6) -
                0.4941058844013093*O(10,-4) - 0.44538102542935076*O(10,-2));
    *c_out++ = (-0.3837778803237379*O(10,0) - 0.18922142726223223*O(10,2) + 0.4585145534256519*O(10,4) +
                0.462890625*O(10,6) - 0.6114934630648914*O(10,8) + 0.13594928558824104*O(10,10));
    *c_out++ = (0.06594508990677396*O(10,-10) - 0.4210060495408587*O(10,-8) + 0.6925528980529664*O(10,-6) -
                0.09110862335695782*O(10,-4) - 0.5748694230132831*O(10,-2));
    *c_out++ = (-0.4306629552848579*O(10,0) + 0.10058119679362292*O(10,2) + 0.6137165055779013*O(10,4) -
                0.6114934630648914*O(10,6) + 0.23046875*O(10,8) - 0.026921970218926214*O(10,10));
    *c_out++ = (-0.008734640537108554*O(10,-10) + 0.09631896879639025*O(10,-8) - 0.36479021288140734*O(10,-6) +
                0.6878550219704731*O(10,-4) - 0.6200241379499873*O(10,-2));
    *c_out++ = (-0.5936279171365733*O(10,0) + 0.6932080600734395*O(10,2) - 0.38452264694764726*O(10,4) +
                0.13594928558824104*O(10,6) - 0.026921970218926214*O(10,8) + 0.001953125*O(10,10));
#endif
#undef O
}
